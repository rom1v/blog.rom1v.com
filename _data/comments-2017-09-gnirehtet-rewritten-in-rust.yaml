- id: 1
  author: Ralf
  date: 2017-09-21 20:25:55+02:00
  contents: |
    > In C and C++, infinite loops without side-effects are undefined behavior.

    Actually, in C (unlike C++), such loops are only UB if the loop condition is
    not a constant expression.  However, LLVM fails to implement this exception
    as is thus breaking some correct C programs.  This has been reported against
    LLVM already more than ten years ago:
    <https://bugs.llvm.org/show_bug.cgi?id=965>.
- id: 2
  author: Istvan Szekeres
  date: 2017-09-22 15:24:26+02:00
  contents: |
    Is the raw field in IPV4Header (and others) necessary? Are those accessed
    besides reading/writing the whole packet, including those headers?

    If not, why don't just use std::mem::transmute the convert the whole raw
    packet to/from the structs, right after reading / before writing the packet?
- id: 3
  author: Â®om
  date: 2017-09-22 16:00:07+02:00
  contents: |
    > @[**Ralf**](#comment-1)
    >
    > Actually, in C (unlike C++), such loops are only UB if the loop condition
    > is not a constant expression.

    Thank you for the precision, I was not aware of this subtlety.

    > @[**Istvan Szekeres**](#comment-2)
    >
    > Is the raw field in IPV4Header (and others) necessary? Are those accessed
    > besides reading/writing the whole packet, including those headers?

    In the device-to-network direction, on new connection, the received headers
    are [copied to a buffer][packetizer-copy], with source and destination
    swapped, so that they are [updated][packetizer-update] (lengths and checksum
    fields) on each packet built for the network-to-device direction.

    [packetizer-copy]: https://github.com/Genymobile/gnirehtet/blob/v2.0/relay-rust/src/relay/packetizer.rs#L46-L58
    [packetizer-update]: https://github.com/Genymobile/gnirehtet/blob/v2.0/relay-rust/src/relay/packetizer.rs#L110-L125
- id: 4
  author: yglukhov
  date: 2017-09-23 00:21:55+02:00
  contents: |
    Thanks for the article, was really a pleasure to read. I wonder if you could
    evaluate Nim lang with the same project of yours.
- id: 5
  author: 0nkery
  date: 2017-09-27 16:37:38+02:00
  contents: |
    Thanks for good article!

    I'm wondering why you didn't implement `EventListener` trait for `Storage`
    struct from your example with `Observer` pattern? Also, you could change a
    signature of `on_event` method to be

    {% highlight rust %}
    pub trait EventListener {
        fn on_event(&mut self, event: u32);
    }
    {% endhighlight %}

    So, your event listeners are free to mutate their state based on given
    event. `Storage` struct greatly benefit from this design.
